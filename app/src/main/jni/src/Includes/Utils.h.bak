#ifndef UTILS
#define UTILS

#include <jni.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
#include <string>
#include <cstdlib>
#include "Logger.h"

pid_t target_pid = -1;
uintptr_t libAddress,anogs;
// Define os syscalls corretamente conforme a arquitetura
#if defined(__aarch64__) || defined(__x86_64__)
#define SYS_process_vm_readv 270
    #define SYS_process_vm_writev 271
#elif defined(__arm__)
#define SYS_process_vm_readv 376
#define SYS_process_vm_writev 377
#elif defined(__i386__)
#define SYS_process_vm_readv 347
    #define SYS_process_vm_writev 348
#else
    #error "Arquitetura não suportada"
#endif

#define halfShift 10
#define UNI_SUR_HIGH_START  (UTF32)0xD800
#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
#define UNI_SUR_LOW_START   (UTF32)0xDC00
#define UNI_SUR_LOW_END     (UTF32)0xDFFF
#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD

typedef char UTF8;
typedef unsigned short UTF16;
typedef unsigned int UTF32;
typedef unsigned char uint8;
typedef unsigned int uint32;
static const UTF32 halfBase = 0x0010000UL;
static const UTF8 firstByteMark[7] = { 0x00, 0x00, static_cast<UTF8>(0xC0), static_cast<UTF8>(0xE0), static_cast<UTF8>(0xF0), static_cast<UTF8>(0xF8), static_cast<UTF8>(0xFC) };

// Encontra o PID do processo pelo nome do pacote
pid_t FindPid(const char *PackageName) {
    char text[69];
    pid_t pid = 0;
    sprintf(text, "pidof %s", PackageName);
    FILE *chkRun = popen(text, "r");
    if (chkRun) {
        char output[10];
        fgets(output ,10, chkRun);
        pclose(chkRun);
        pid = atoi(output);
    }
    return pid;
}

// Encontra o endereço base de uma biblioteca dentro do processo alvo
uintptr_t FindLibrary(const char* name, int index) {
    int i = 0;
    long start = 0;
    char line[1024] = {0};
    char dname[128], fname[128];

    sprintf(dname, "%s", name);
    sprintf(fname, "/proc/%d/maps", target_pid);
    FILE* p = fopen(fname, "r");
    if (p) {
        while (fgets(line, sizeof(line), p)) {
            if (strstr(line, dname) != NULL) {
                i++;
                if (i == index) {
                    sscanf(line, "%lx", &start);
                    break;
                }
            }
        }
        fclose(p);
    }
    return start;
}

template<class T>
T Read(uintptr_t address) {
    T buf;
    struct iovec iov_ReadBuffer, iov_ReadOffset;
    iov_ReadBuffer.iov_base = (void *) &buf;
    iov_ReadBuffer.iov_len = sizeof(buf);
    iov_ReadOffset.iov_base = (void *) address;
    iov_ReadOffset.iov_len = sizeof(buf);
    syscall(SYS_process_vm_readv, target_pid, &iov_ReadBuffer, 1, &iov_ReadOffset, 1, 0);
    return buf;
}

// Escreve memória usando process_vm_writev (32 e 64 bits)
template<typename T>
void Write(uintptr_t address, T value) {
    struct iovec local[1], remote[1];

    local[0].iov_base = (void *)&value;
    local[0].iov_len = sizeof(T);
    remote[0].iov_base = (void *)address;
    remote[0].iov_len = sizeof(T);

    syscall(SYS_process_vm_writev, target_pid, local, 1, remote, 1, 0);
}

uintptr_t getMemoryAddr(uintptr_t address) {
    return Read<uintptr_t>(address);
}

__attribute__((always_inline))
static inline int my_open_mem(int pid) {
    const char * proc ="/proc/";
    const char * mem = "/mem";
    std::string path = proc + std::to_string(pid) + mem;
    return (int) syscall(5, path.c_str(), 00000002);
}

int mem_fd = 0;
#include <sstream>
#include <fstream>

std::vector<uint8_t> ParseHexBytes(const std::string& hexString) {
    std::vector<uint8_t> bytes;
    std::istringstream stream(hexString);
    std::string byteStr;
    while (stream >> byteStr)
    {
        bytes.push_back(static_cast<uint8_t>(std::stoul(byteStr, nullptr, 16)));
    }
    return bytes;
}

void WriteIO(uintptr_t address, const std::string& hexString)
{
    std::vector<uint8_t> bytes = ParseHexBytes(hexString);

    pwrite64(mem_fd, bytes.data(), bytes.size(), address);
}

struct D3DMatrix {
    float _11, _12, _13, _14;
    float _21, _22, _23, _24;
    float _31, _32, _33, _34;
    float _41, _42, _43, _44;
};
struct Vector4 {
    float X;
    float Y;
    float Z;
    float W;
};


class MonoDictionary
{
public:
    auto getValues()
    {
        return Read<uintptr_t>(uintptr_t(this) + 0x14) + 0x10;
    }
    auto getNumValues()
    {
        return Read<int>(uintptr_t(this) + 0x18);
    }
};




uintptr_t string2Offset(const char *c)
{
    int base = 16;
    // See if this function catches all possibilities.
    // If it doesn't, the function would have to be amended
    // whenever you add a combination of architecture and
    // compiler that is not yet addressed.
    static_assert(sizeof(uintptr_t) == sizeof(unsigned long) || sizeof(uintptr_t) == sizeof(unsigned long long), "Please add string to handle conversion for this architecture.");

    // Now choose the correct function ...
    if (sizeof(uintptr_t) == sizeof(unsigned long)) {
        return strtoul(c, nullptr, base);
    }

    // All other options exhausted, sizeof(uintptr_t) == sizeof(unsigned long long))
    return strtoull(c, nullptr, base);
}

typedef enum
{
    strictConversion = 0,
    lenientConversion
} ConversionFlags;

typedef enum
{
    conversionOK,    /* conversion successful */
    sourceExhausted,   /* partial character in source, but hit end */
    targetExhausted,   /* insuff. room in target for conversion */
    sourceIllegal,    /* source sequence is illegal/malformed */
    conversionFailed
} ConversionResult;

int Utf16_To_Utf8(const UTF16 * sourceStart, UTF8 * targetStart, size_t outLen,
                  ConversionFlags flags)
{
    int result = 0;
    const UTF16 *source = sourceStart;
    UTF8 *target = targetStart;
    UTF8 *targetEnd = targetStart + outLen;

    if ((NULL == source) || (NULL == targetStart))
    {
        printf("ERR, Utf16_To_Utf8: source=%p, targetStart=%p\n", source, targetStart);
        return conversionFailed;
    }

    while (*source)
    {
        UTF32 ch;
        unsigned short bytesToWrite = 0;
        const UTF32 byteMask = 0xBF;
        const UTF32 byteMark = 0x80;
        const UTF16 *oldSource = source;

        ch = *source++;

        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END)
        {

            if (*source)
            {
                UTF32 ch2 = *source;

                if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END)
                {
                    ch = ((ch - UNI_SUR_HIGH_START) << halfShift) + (ch2 - UNI_SUR_LOW_START) +
                         halfBase;
                    ++source;
                }
                else if (flags == strictConversion)
                {
                    --source;
                    result = sourceIllegal;
                    break;
                }
            }
            else
            {
                --source;
                result = sourceExhausted;
                break;
            }
        }
        else if (flags == strictConversion)
        {
            if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END)
            {
                --source;
                result = sourceIllegal;
                break;
            }
        }

        if (ch < (UTF32) 0x80)
        {
            bytesToWrite = 1;
        }
        else if (ch < (UTF32) 0x800)
        {
            bytesToWrite = 2;
        }
        else if (ch < (UTF32) 0x10000)
        {
            bytesToWrite = 3;
        }
        else if (ch < (UTF32) 0x110000)
        {
            bytesToWrite = 4;
        }
        else
        {
            bytesToWrite = 3;
            ch = UNI_REPLACEMENT_CHAR;
        }

        target += bytesToWrite;
        if (target > targetEnd)
        {
            source = oldSource;
            target -= bytesToWrite;
            result = targetExhausted;
            break;
        }
        switch (bytesToWrite)
        {
            case 4:
                *--target = (UTF8) ((ch | byteMark) & byteMask);
                ch >>= 6;
            case 3:
                *--target = (UTF8) ((ch | byteMark) & byteMask);
                ch >>= 6;
            case 2:
                *--target = (UTF8) ((ch | byteMark) & byteMask);
                ch >>= 6;
            case 1:
                *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
        }
        target += bytesToWrite;
    }
    return result;
}

void getCharacterName(uintptr_t address, UTF8 * transcoding)
{
    int classname;
    int m = 0;
    UTF8 buf88[256] = "";
    UTF16 buf16[34] = {0};
    int hex[2] = {0};
    for (int i = 0; i < 4; i++)
    {
        classname = Read<int>(address + i * 4);
        hex[0] = (classname & 0xfffff000) >> 16;
        hex[1] = classname & 0xffff;
        buf16[m] = hex[1];
        buf16[m + 1] = hex[0];
        m += 2;
    }
    Utf16_To_Utf8(buf16, buf88, sizeof(buf88), strictConversion);
    sprintf(transcoding, "%s", buf88);
}

#endif
